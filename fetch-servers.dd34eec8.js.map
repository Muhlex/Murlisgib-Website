{"version":3,"sources":["js/fetch-servers.js"],"names":["clusters","url","ready","fun","document","readyState","addEventListener","chunk","array","size","result","index","length","push","slice","getResponseValueByKey","responseLines","key","regexp","RegExp","matchedLine","find","line","match","parseResponse","responseText","split","map","serverResponseLines","playersString","port","Number","online","Boolean","hostname","players","bots","maxplayers","titleCase","str","toLowerCase","word","toUpperCase","join","getMapDisplayName","prefix","filenameMatch","filename","startsWith","replace","updateHTML","clusterIndex","servers","clusterEl","querySelector","serverEls","querySelectorAll","classList","add","forEach","mapEl","playersEl","statusEl","innerHTML","isNaN","remove","update","response","fetch","rawData","text","error","console","warn","updateEvery","updateInterval","window","setInterval","visibilityState","clearInterval"],"mappings":"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","file":"fetch-servers.dd34eec8.js","sourceRoot":"../src","sourcesContent":["const clusters = [\r\n  { url: \"https://eu.gib.murl.is/serverinfo.txt\" }\r\n];\r\n\r\nfunction ready(fun) {\r\n  if (document.readyState != 'loading') {\r\n    fun();\r\n  } else {\r\n    document.addEventListener('DOMContentLoaded', fun);\r\n  }\r\n}\r\n\r\nfunction chunk(array, size) {\r\n  const result = [];\r\n  let index = 0;\r\n  while (index < array.length) {\r\n    result.push(array.slice(index, size + index));\r\n    index += size;\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction getResponseValueByKey(responseLines, key) {\r\n  const regexp = new RegExp(`${key} *: (.*)`);\r\n  const matchedLine = responseLines.find(line => line.match(regexp));\r\n  return matchedLine && matchedLine.match(regexp)[1];\r\n}\r\n\r\nfunction parseResponse(responseText) {\r\n  const responseLines = responseText.split('\\n');\r\n  return chunk(responseLines, 6).map(serverResponseLines => {\r\n    const playersString = getResponseValueByKey(serverResponseLines, 'players');\r\n    return {\r\n      port: Number(getResponseValueByKey(serverResponseLines, 'port')),\r\n      online: Boolean(Number(getResponseValueByKey(serverResponseLines, 'online'))),\r\n      hostname: getResponseValueByKey(serverResponseLines, 'hostname'),\r\n      map: getResponseValueByKey(serverResponseLines, 'map'),\r\n      players: playersString && Number(playersString.match(/(\\d+) humans/)[1]),\r\n      bots: playersString && Number(playersString.match(/(\\d+) bots/)[1]),\r\n      maxplayers: playersString && Number(playersString.match(/(\\d+)\\/\\d+ max/)[1]),\r\n    };\r\n  });\r\n};\r\n\r\nfunction titleCase(str) {\r\n  return str.toLowerCase().split(' ').map(function (word) {\r\n    return (word[0].toUpperCase() + word.slice(1));\r\n  }).join(' ');\r\n}\r\n\r\nfunction getMapDisplayName(map, prefix = '') {\r\n  const filenameMatch = map.match(/.*\\/(.*)/);\r\n  let filename = filenameMatch ? filenameMatch[1] : map;\r\n  if (filename.toLowerCase().startsWith(prefix.toLowerCase())) filename = filename.slice(prefix.length);\r\n  return titleCase(filename.replace(/_/g, ' '));\r\n}\r\n\r\nfunction updateHTML(clusterIndex, servers) {\r\n  const clusterEl = document.querySelector(`[data-server-cluster-index='${clusterIndex}']`);\r\n  const serverEls = clusterEl.querySelectorAll(\"[data-server-index]\");\r\n\r\n  clusterEl.classList.add(\"synced\");\r\n\r\n  servers.forEach(({ online, players, maxplayers, map }, index) => {\r\n    const mapEl = serverEls[index].querySelector(\".servers__map\");\r\n    const playersEl = serverEls[index].querySelector(\".servers__players\");\r\n    const statusEl = serverEls[index].querySelector(\".servers__status\");\r\n\r\n    mapEl.innerHTML = map ? getMapDisplayName(map, 'mg_') : \"&ndash;\";\r\n    playersEl.innerHTML = !isNaN(players) ? `${players}/${maxplayers || '?'}` : '&ndash;';\r\n    statusEl.innerHTML = online ? \"Online\" : \"Offline\";\r\n    serverEls[index].classList.remove(online ? \"offline\" : \"online\");\r\n    serverEls[index].classList.add(online ? \"online\" : \"offline\");\r\n  });\r\n};\r\n\r\nasync function update() {\r\n  clusters.forEach(async ({ url }, clusterIndex) => {\r\n    let servers = [];\r\n\r\n    try {\r\n      const response = await fetch(url);\r\n      const rawData = await response.text();\r\n      servers = parseResponse(rawData);\r\n    } catch (error) {\r\n      console.warn(\"Could not fetch data for cluster\", clusterIndex, \"at\", url);\r\n      console.error(error);\r\n    }\r\n    ready(() => updateHTML(clusterIndex, servers));\r\n  });\r\n};\r\n\r\nupdate();\r\nconst updateEvery = 60;\r\nlet updateInterval = window.setInterval(update, 1000 * updateEvery);\r\n\r\ndocument.addEventListener(\"visibilitychange\", () => {\r\n  if (document.visibilityState === 'visible') {\r\n    update();\r\n    updateInterval = window.setInterval(update, 1000 * updateEvery);\r\n  } else {\r\n    window.clearInterval(updateInterval);\r\n  }\r\n});\r\n"]}